 48// ----------------------------
#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <ESP8266WebServer.h>
#include <TimeLib.h>
#include <EEPROM.h>

// ----------------------------
// Additional Libraries - each one of these will need to be installed.
// ----------------------------

#include <ArduinoJson.h> // Library used for parsing Json from the API responses
#include <MD_MAX72xx.h>  // Library used for interfacing with the 8x8x4 led matrix
#include <MD_Parola.h>   // Library used for displaying info on the matrix
#include <NTPClient.h>   // Library to get the current time
#include <WiFiUdp.h>     // Library to get the time from a udp server

// Search for "Arduino Json" in the Arduino Library manager
// https://github.com/bblanchon/ArduinoJson


// LED MATRIX DISPLAY DEFINITION
#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_DEVICES  4 //8
#define CLK_PIN   D5  // or SCK
#define DATA_PIN  D7  // or MOSI
#define CS_PIN    D8  // or SS

#define DOLIBO_USERNAME_LEN_MAX     128      //bytes
#define WIFI_STATION_RUNNING_OK     5       //seconds
#define WIFI_SSID_LEN_MAX           128      //bytes
#define WIFI_PASSWORD_LEN_MAX       128      //bytes
#define WIFI_AP_DOLIBO_SSID         "DOLIBO-MatrixDisplay"
#define WIFI_AP_GUIDE_TEXT          "Connect to DOLIBO-MatrixDisplay through WiFi... Then go to 192.168.4.1 in a browser"
#define START_MODE_COUNTER_MAX      0x03
#define RUNNING_MODE_WIFI_AP        0x01
#define RUNNING_MODE_WIFI_STATION    0x02

#define EP_CAPACITY                 512     //bytes
#define EP_IDENTIFIER               0xAA
#define EP_IDENTIFIER_ADDR          0x00
#define EP_START_MODE_ADDR          0x01
#define EP_WIFI_SSID_ADDR           0x02
#define EP_WIFI_PASSWORD_ADDR       (EP_WIFI_SSID_ADDR + WIFI_SSID_LEN_MAX)
#define EP_DOLIBO_USERNAME_ADDR     (EP_WIFI_PASSWORD_ADDR + WIFI_PASSWORD_LEN_MAX)

MD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, DATA_PIN, CLK_PIN, CS_PIN, MAX_DEVICES);
//

int TRANSITION_TIME_SEC =           ( 4 * 1000 );
const int timeDelay = 3000; // Delay between Time / Day / Subs / Views
const int fadeSpeed = 40;   // Speed of the fade
int i = 0; // looping through the display init at 0
int statusCode;

const int fadeDuration = 3000/2;

const float numIterations = 15.0;
const int clockedIterations = 50;
const float iterationOffset = (fadeDuration/clockedIterations) * 1.0;

String st;
String content;


enum class State : uint8_t {
  fetch,
  noop,
  wait,
  fadeIn,
  fadeOut
};

enum class Values : uint8_t {
  curTime = 0,
  weekDay = 1,
  curDate = 2,
  yt_channel = 3,
  yt_subscribers = 4,
  yt_views = 5,
//   tw_title = 6,
//   tw_account = 7,
//   tw_followers = 8,
//   tw_friends = 9,
//   tw_tweets = 10,
  count = 6 //11
};

typedef enum {
  E_TRANS_TYPE_FADE = (0),
  E_TRANS_TYPE_SCROLL
} e_TransitionType;

typedef enum {
  E_SCROLL_SPEED_SLOW = (0),
  E_SCROLL_SPEED_MEDIUM,
  E_SCROLL_SPEED_FAST
} e_ScrollSpeed;

/* Number of elements mus be equal Values.count */
boolean g_dispState[] = { 
  /* Time */    false,  //false,
  /* Day */     false,  //false,
  /* Date */    false,  //true,
  /* Channel */ true, //true,
  /* Subs */    true, //true,
  /* Views */   true, //true
};

static int g_dispTextIdx = 0;

State nextState;
State state;

uint32_t prevTime = millis();
uint32_t currentTime = millis();
uint32_t waitDelay;

volatile static uint32_t waitDelay_fetch = 60000;
#define WAI_DELAY_FETCH       (300000)
//uint32_t waitDelay_fetch = 20 * 1000;

//uint32_t prevTime_fetch = millis() + waitDelay_fetch * 2;
uint32_t prevTime_fetch = millis() + WAI_DELAY_FETCH * 2;

String feed[(uint8_t)Values::count] = {};

//YouTube
String youtube_views = "";
String youtube_channel = "";
String youtube_subscribers = "";
String youtube_videos = "";

//Time Variables
WiFiUDP ntpUDP; // Define NTP Client to get time
NTPClient timeClient(ntpUDP, "pool.ntp.org");

String weekDays[7] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; //Day Names
String myMonthStr[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
char *AMPM = "AM"; // AM / PM // Variable

//-----------------------------
// For HTTPS requests - keep this
WiFiClientSecure client;

// Just the base of the URL you want to connect to
#define CODE_DOLIBO_HOST "code.dolibo.com" //leave this alone


/* Don't set this wifi credentials. They are configurated at runtime and stored on EEPROM */
char ssid[WIFI_SSID_LEN_MAX] = "Zero and One";
char password[WIFI_PASSWORD_LEN_MAX] = "i@mc0nnected";
char project[DOLIBO_USERNAME_LEN_MAX] = "userinfo/";
char g_username[DOLIBO_USERNAME_LEN_MAX] = "asif";


// Web server
ESP8266WebServer apserver(80);

/* Soft AP network parameters */
IPAddress apIP(192, 168, 4, 1);
IPAddress netMsk(255, 255, 255, 0);


/** Should I connect to WLAN asap? */
boolean connect;

/** Last time I tried to connect to WLAN */
unsigned long lastConnectTry = 0;

/** Current WLAN status */
unsigned int status = WL_IDLE_STATUS;

static uint8_t g_scrollSpeed = E_SCROLL_SPEED_MEDIUM;
static uint8_t g_transitionType = E_TRANS_TYPE_FADE;
static uint8_t g_runningMode = RUNNING_MODE_WIFI_AP;
static boolean g_isWifiStationOk = false;
static String  g_scrollingText = "";
static boolean g_isUserValid = true;

static int g_wifiSsidID = 0;
static int g_networkNum = 0;

void(* SoftReset) (void) = 0;  // declare reset fuction at address 0
void handleWebRoot( void );
void handleOptionNo( void );
void handleSelectNetwork( void );
void handleInputPassword( void );
void handleWifiConnected( void );
void handleConnectWifi( void );
void handleNotFound( void );

int LocalGetScrollSpeedMs(uint8_t type)
{
  int speed = 100;
  switch (type)
  {
    case E_SCROLL_SPEED_SLOW:   speed = 100; break;
    case E_SCROLL_SPEED_MEDIUM: speed = 50; break;
    case E_SCROLL_SPEED_FAST:   speed = 25; break;
    default: break;
  }

  return speed;
}

/** Is this an IP? */
boolean isIp(String str) {
  for (size_t i = 0; i < str.length(); i++) {
    int c = str.charAt(i);
    if (c != '.' && (c < '0' || c > '9')) {
      return false;
    }
  }
  return true;
}

/** IP to String? */
String toStringIp(IPAddress ip) {
  String res = "";
  for (int i = 0; i < 3; i++) {
    res += String((ip >> (8 * i)) & 0xFF) + ".";
  }
  res += String(((ip >> 8 * 3)) & 0xFF);
  return res;
}

void setup() {
  uint8_t i = 0;
  delay(1000);
  Serial.begin(115200);
  
  //initialize the LED MAtrix 8, 8x8
  myDisplay.begin();
  myDisplay.setIntensity(10);
  myDisplay.setTextAlignment(PA_CENTER);
  myDisplay.setPause(2000);
  myDisplay.setSpeed(40);
  myDisplay.displayClear();
  myDisplay.print("Loading...");
  
  unsigned long loading_delay = millis();
  while (millis() - loading_delay < 1000) {
    yield();
  }

  if (strlen(ssid) == 0 || (strlen(password) < 0 && strlen(password) < 8) || strlen(g_username) == 0)
  {
    Serial.println("Fixed WiFi settings invalid. Checking EEPROM...");

    EEPROM.begin(EP_CAPACITY);
    uint8_t epId = EEPROM.read(EP_IDENTIFIER_ADDR);

    if (epId == EP_IDENTIFIER)
    {
      uint8_t startMode = EEPROM.read(EP_START_MODE_ADDR);
      Serial.print("Start mode counter: "); Serial.println(startMode, DEC);
      
      if (startMode > 0) {
        startMode--;
        EEPROM.write(EP_START_MODE_ADDR, startMode);
        EEPROM.commit();
      }
      
      if (startMode > 0) {
        g_runningMode = RUNNING_MODE_WIFI_STATION;
        
        //Read SSID and Password from EEPROM
        memset(ssid, 0, WIFI_SSID_LEN_MAX);
        memset(password, 0, WIFI_PASSWORD_LEN_MAX);
        memset(g_username, 0, DOLIBO_USERNAME_LEN_MAX);
        for (i = 0; i < WIFI_SSID_LEN_MAX - 1; i++)
        {
          ssid[i] = EEPROM.read(EP_WIFI_SSID_ADDR + i);
        }

        for (i = 0; i < WIFI_PASSWORD_LEN_MAX - 1; i++)
        {
          password[i] = EEPROM.read(EP_WIFI_PASSWORD_ADDR + i);
        }

        for (i = 0; i < DOLIBO_USERNAME_LEN_MAX - 1; i++)
        {
          g_username[i] = EEPROM.read(EP_DOLIBO_USERNAME_ADDR + i);
        }

        strcat(project, g_username);
        Serial.print("Username path: "); Serial.println(project);

        ssid[WIFI_SSID_LEN_MAX - 1] = 0;
        password[WIFI_PASSWORD_LEN_MAX - 1] = 0;

        if (String(ssid).length() == 0 || (0 <= String(password).length() && String(password).length() < 8)
            || ssid[0] > 128 || password[0] > 128 || g_username[0] > 128 )
        {
          Serial.print("Set up invalid Wifi information: ");
          Serial.print(ssid); Serial.print(" - ");
          Serial.print(password); Serial.print(" - ");
          Serial.print(g_username); Serial.println("");

          g_runningMode = RUNNING_MODE_WIFI_AP;
        }
        else {
          Serial.print("SSID: "); Serial.println(ssid);
          Serial.print("Password: "); Serial.println(password);
        }
      }
      else {
        //Wifi AP mode
        g_runningMode = RUNNING_MODE_WIFI_AP;
      }
    }
    else {
      Serial.print("EEPROM has wrong ID: "); Serial.println(epId, DEC);
      EEPROM.write(EP_IDENTIFIER_ADDR, EP_IDENTIFIER);
      EEPROM.write(EP_START_MODE_ADDR, 0x00);
      EEPROM.commit();
      g_runningMode = RUNNING_MODE_WIFI_AP;
    }
  }
  else {
    Serial.println("Checking fixed WiFi settings... OK");
    strcat(project, g_username);
    g_runningMode = RUNNING_MODE_WIFI_STATION;
  }

  if (g_runningMode == RUNNING_MODE_WIFI_AP)
  {
    Serial.println("WIFI Access Point mode");
    WiFi.mode(WIFI_AP);
    boolean conn = WiFi.softAP(WIFI_AP_DOLIBO_SSID);
    apserver.on( "/", handleWebRoot );
    apserver.on( "/home", handleWebRoot );
    apserver.on( "/option-no", handleOptionNo );
    apserver.on( "/select-network", handleSelectNetwork );
    apserver.on( "/input-password", handleInputPassword );
    apserver.on( "/connect-wifi", handleConnectWifi );
    apserver.on( "/wifi-connected", handleWifiConnected );
    apserver.onNotFound( handleNotFound );

    apserver.begin();
  } else {
    Serial.println("WIFI Client mode");
  }

  i = 0;
  while ( g_dispState[i] == false ) {
    i++;
    if (i == (uint8_t)Values::count) {
      i = 0;
      g_dispState[i] = true;
      break;
    }
  }
  g_dispTextIdx = i;

  //Get the local time
  timeClient.begin(); // Initialize NTPClient --> get time
  timeClient.setTimeOffset(21600);  // Set offset time in seconds to adjust for your timezone: 3600 sec per Hour
  connect = strlen(ssid) > 0; // Request WLAN connect if there is a SSID
  
  if (g_runningMode == RUNNING_MODE_WIFI_AP)
  {
    g_scrollingText = WIFI_AP_GUIDE_TEXT;
    myDisplay.displayScroll(g_scrollingText.c_str(), PA_CENTER, PA_SCROLL_LEFT, LocalGetScrollSpeedMs(g_scrollSpeed));
  }
}

void connectWifi() {
  Serial.println("Connecting as wifi station...");
  WiFi.disconnect();
  WiFi.begin(ssid, password);
  int connRes = WiFi.waitForConnectResult();
  client.setInsecure();
  Serial.print("connRes: ");
  Serial.println(connRes);
}

void makeHTTPRequest() {
  Serial.println(project);
  Serial.println(CODE_DOLIBO_HOST);
  // Opening connection to server (Use 80 as port if HTTP)
  if (!client.connect(CODE_DOLIBO_HOST, 443))
  {
    Serial.println(F("Connection failed"));
    return;
  }

  // give the esp a breather
  yield();

  // Send HTTP request
  client.print(F("GET "));
  // This is the second half of a request (everything that comes after the base URL)
  client.print("/"); // %2C == , mFljAbJMtaaDxSxDN48DuK0hpDc2
  client.print(String(project));
  client.println(F(" HTTP/1.1"));
  Serial.println(client);
  //Headers
  client.print(F("Host: "));
  client.println(CODE_DOLIBO_HOST);
  client.println("Connection: close");
  client.println(F("Cache-Control: max-age=0"));

  if (client.println() == 0)
  {
    Serial.println(F("Failed to send request"));
    return;
  }

  // Check HTTP status
  char status[32] = {0};
  client.readBytesUntil('\r', status, sizeof(status));
  if (strcmp(status, "HTTP/1.1 200 OK") != 0)
    //  {
    //    Serial.print(F("Unexpected response: "));
    //    Serial.println(status);
    //    return;
    //  }

    // Skip HTTP headers
    char endOfHeaders[] = "\r\n\r\n";
  //  if (!client.find(endOfHeaders))
  //  {
  //    Serial.println(F("Invalid response"));
  //    return;
  //  }


  // peek() will look at the character, but not take it off the queue
  while (client.available() && client.peek() != '{')
  {
    char c = 0;
    client.readBytes(&c, 1);
    Serial.print(c);
  }

  String jsonResponse = "";
  while (client.connected())
  {
    while (client.available()) {
      char c = 0;
      client.readBytes(&c, 1);
      jsonResponse += c;
      Serial.print(c);
    }
  }

  while (client.available()) {
    char c = 0;
    client.readBytes(&c, 1);
    jsonResponse += c;
    Serial.print(c);
  }

  client.stop();
  Serial.println("");
  Serial.println("JSON String:");
  Serial.println(jsonResponse);

  //Use the ArduinoJson Assistant to calculate this:
  DynamicJsonDocument doc(1024); //For ESP32/ESP8266 you'll mainly use dynamic.

//  DeserializationError error = deserializeJson(doc, client);
  DeserializationError error = deserializeJson(doc, jsonResponse);

  if (error) {
    Serial.print(F("deserializeJson() failed: "));
    Serial.println(error.f_str());
    return;
  }

  if (doc["youtube"].isNull() == true)
  {
    if (doc["message"].isNull() == false) {
      if (doc["message"].as<String>().indexOf("User doesn't exist") >= 0) {
        Serial.print("Username "); Serial.print(g_username);Serial.println(" not found.");
        g_isUserValid = false;
        g_scrollingText = g_username + String(" not found.");
        myDisplay.displayClear();
        myDisplay.displayScroll(g_scrollingText.c_str(), PA_CENTER, PA_SCROLL_LEFT, LocalGetScrollSpeedMs(g_scrollSpeed));
        return;
      }
    }
  }

  JsonObject youtube = doc["youtube"];
  youtube_views = youtube["views"].as<String>(); 
  youtube_channel = youtube["channel"].as<String>(); 
  youtube_subscribers = youtube["subscribers"].as<String>(); 
  youtube_videos = youtube["videos"].as<String>();

  String tmp = "";

  if ( youtube["timezone"].isNull() == false ) {
    //timezone = youtube["timezone"];
    timeClient.setTimeOffset(youtube["timezone"]);
  }
  if ( youtube["dispTime"].isNull() == false ) {
    tmp = youtube["dispTime"].as<String>();
    g_dispState[(uint8_t)Values::curTime] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::curTime]);
  }
  if ( youtube["dispDate"].isNull() == false ) {
    tmp = youtube["dispDate"].as<String>();
    g_dispState[(uint8_t)Values::curDate] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::curDate]);
  }
  if ( youtube["dispDay"].isNull() == false ) {
    tmp = youtube["dispDay"].as<String>();
    g_dispState[(uint8_t)Values::weekDay] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::weekDay]);
  }
  if ( youtube["dispChannel"].isNull() == false ) {
    tmp = youtube["dispChannel"].as<String>();
    g_dispState[(uint8_t)Values::yt_channel] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::yt_channel]);
  }
  if ( youtube["dispSubs"].isNull() == false ) {
    tmp = youtube["dispSubs"].as<String>();
    g_dispState[(uint8_t)Values::yt_subscribers] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::yt_subscribers]);
  }
  if ( youtube["dispViews"].isNull() == false ) {
    tmp = youtube["dispViews"].as<String>();
    g_dispState[(uint8_t)Values::yt_views] = (tmp == String("true")? true :
                            tmp == String("false")? false : g_dispState[(uint8_t)Values::yt_views]);
  }
  if ( youtube["transitionTime"].isNull() == false ) {
    TRANSITION_TIME_SEC = youtube["transitionTime"];

    /* Convert transition time to scrolling speed */
    if (0 <= TRANSITION_TIME_SEC  && TRANSITION_TIME_SEC <= 2) {
      g_scrollSpeed = E_SCROLL_SPEED_FAST;
    }
    else if (2 < TRANSITION_TIME_SEC  && TRANSITION_TIME_SEC <= 4) {
      g_scrollSpeed = E_SCROLL_SPEED_MEDIUM;
    }
    else {
      g_scrollSpeed = E_SCROLL_SPEED_SLOW;
    }

    /* For Fade animation */
    if ( TRANSITION_TIME_SEC < 3 ) {
      TRANSITION_TIME_SEC = 3;
    }
    TRANSITION_TIME_SEC *= 1000;
    Serial.print("Transition time update to: ");Serial.println(TRANSITION_TIME_SEC, DEC);
    TRANSITION_TIME_SEC -= 1500; //Fading in/out time
  }
  if ( youtube["transitionType"].isNull() == false ) {
    uint8_t prevType = g_transitionType;
    g_transitionType = youtube["transitionType"];

    if (g_transitionType != prevType)
    {
      myDisplay.displayReset();
      if (g_transitionType == E_TRANS_TYPE_SCROLL)
      {
        configureData();
        myDisplay.displayScroll(g_scrollingText.c_str(), PA_CENTER, PA_SCROLL_LEFT, LocalGetScrollSpeedMs(g_scrollSpeed));
      }
    }
  }

  //YouTube
//  feed[(uint8_t)Values::yt_title] = "Youtube";
  feed[(uint8_t)Values::yt_channel] = youtube_channel;
}

void nextStateAfter(State ss, uint32_t d) {
  waitDelay = d;
  nextState = ss;
  state = State::wait;
  prevTime = currentTime;
}

void statemachine() {
  static float i = 0.0;
  static unsigned long display_time = millis();

  switch (state) {
    case State::noop:
      //maybe wait for input? (for now just send anything to serial);
      if (Serial.available() > 0) {
        Serial.readString();
        state = State::fadeIn;
      }
      break;
    case State::fetch:
      if (currentTime - prevTime_fetch > WAI_DELAY_FETCH) {
        makeHTTPRequest();
        prevTime_fetch = millis();
        Serial.println("Getting Data after 5 Minutes");
      }
      nextStateAfter(State::fadeIn, 50);
      break;
    case State::wait:
      if (currentTime - prevTime > waitDelay) {
        state = nextState;
        prevTime = currentTime;
      }
      break;
    case State::fadeIn:
      //clear the display
//      Serial.println(feed[g_dispTextIdx]);
//      Serial.print(i);Serial.print(" ");
//      Serial.println(numIterations / iterationOffset);

      myDisplay.print(feed[g_dispTextIdx]);
      //set the display intensity

      if ( i <= numIterations ) {
        i += numIterations / iterationOffset;
      }

      if (i > numIterations) {
        if ( millis() - display_time >= TRANSITION_TIME_SEC ) {
//          Serial.print("Current: "); Serial.print(millis());
//          Serial.print(" - Prev disp: ");Serial.print(display_time, DEC); Serial.print(" - Trans time: ");
//          Serial.println(TRANSITION_TIME_SEC, DEC);
          nextStateAfter(State::fadeOut, clockedIterations);
        }
      } else if (i == 0) {
        myDisplay.displayClear();
      } else {
        nextStateAfter(State::fadeIn, clockedIterations);
        myDisplay.setIntensity(i);
      }
      break;

    case State::fadeOut:

//      Serial.println(feed[g_dispTextIdx]);
      //Serial.println(i);
      myDisplay.print(feed[g_dispTextIdx]);

      if ( i > 0 ) {
        i -= numIterations / iterationOffset;
      }

      if ( i <= 0 ) {
        g_dispTextIdx++;
        myDisplay.displayClear();
        display_time = millis();

        if (g_dispTextIdx == (uint8_t)Values::count) {
          g_dispTextIdx = 0;
          nextStateAfter(State::fetch, 0);
        } else {
          nextStateAfter(State::fadeIn, clockedIterations);
        }

        while ( g_dispState[g_dispTextIdx] == false )
        {
          g_dispTextIdx++;

          if (g_dispTextIdx == (uint8_t)Values::count) {
            g_dispTextIdx = 0;
          }
        }

        Serial.println(feed[g_dispTextIdx]);
      } else {
        nextStateAfter(State::fadeOut, clockedIterations);
        myDisplay.setIntensity(i);
      }

//      Serial.print("cur: "); Serial.print(currentTime, DEC); Serial.print(" - prev: ");
//      Serial.print(prevTime_fetch, DEC); Serial.print(" - delay: "); Serial.println(waitDelay_fetch, DEC);
      if (currentTime - prevTime_fetch > WAI_DELAY_FETCH) {
        Serial.println("Fetching...");
        nextStateAfter(State::fetch, 0);
      }
      break;

  }
}

void loop() {
  currentTime = millis();

  if (g_isUserValid == false)
  {
    if (myDisplay.displayAnimate())
    {
      myDisplay.displayReset();
    }
    return;
  }

  if ( g_runningMode == RUNNING_MODE_WIFI_STATION )
  {
    if ( g_isWifiStationOk == false )
    {
      if (millis() > WIFI_STATION_RUNNING_OK*1000)
      {
        g_isWifiStationOk = true;
        EEPROM.write(EP_START_MODE_ADDR, START_MODE_COUNTER_MAX);
        EEPROM.commit();
      }
    }
      
    if (connect) {
      Serial.println("Connect requested");
      connect = false;
      connectWifi();
      lastConnectTry = millis();
    }

    unsigned int s = WiFi.status();
    if (s == 0 && millis() > (lastConnectTry + 60000)) {
      /* If WLAN disconnected and idle try to connect */
      /* Don't set retry time too low as retry interfere the softAP operation */
      connect = true;
    }

    if (status != s) { // WLAN status change
      Serial.print("Status: ");
      Serial.println(s);
      status = s;
      if (s == WL_CONNECTED) {
        /* Just connected to WLAN */
        Serial.println("");
        Serial.print("Connected to ");
        Serial.println(ssid);
        Serial.print("IP address: ");
        Serial.println(WiFi.localIP());

      } else if (s == WL_NO_SSID_AVAIL) {
        WiFi.disconnect();
      }
    }
    if (s == WL_CONNECTED) {
      timeClient.update();
    }
    else {
    }

    // Do work:
    configureData();

    if (g_transitionType == E_TRANS_TYPE_SCROLL)
    {
      if (myDisplay.displayAnimate()) {
        myDisplay.displayReset();
        Serial.print("Scrolling text: "); Serial.println(g_scrollingText);
        myDisplay.displayScroll(g_scrollingText.c_str(), PA_CENTER, PA_SCROLL_LEFT, LocalGetScrollSpeedMs(g_scrollSpeed));
      }

      if (currentTime - prevTime_fetch > WAI_DELAY_FETCH) {
        makeHTTPRequest();
        prevTime_fetch = currentTime;
        configureData();
      }
    }
    else {
      //STATE
      statemachine();
    }
  }
  else  //WIFI Access Point mode
  {
    if (myDisplay.displayAnimate())
    {
      myDisplay.displayReset();
      myDisplay.displayScroll(g_scrollingText.c_str(), PA_CENTER, PA_SCROLL_LEFT, LocalGetScrollSpeedMs(g_scrollSpeed));
    }

    apserver.handleClient();
  }
}


void configureData() {
  timeClient.update();

  int currentHour = timeClient.getHours();
  int currentMinute = timeClient.getMinutes();
  int epochTime = timeClient.getEpochTime();
  //AM or PM adjustment
  if (currentHour >= 12)
  {
    AMPM = "PM";
  }
  else(AMPM = "AM");
  if (currentHour >= 13) currentHour = currentHour - 12;
  if (currentHour == 0) currentHour = 12;

  String weekDay = weekDays[timeClient.getDay()];
  //  Serial.println(weekDay);

  char time[40];
  sprintf(time, "%d:%i %s", currentHour, currentMinute, AMPM);

  if (currentMinute < 10) //Adds a leading 0 before a single digit minute
  {
    sprintf(time, "%d:0%i %s", currentHour, currentMinute, AMPM);
  }
  else sprintf(time, "%d:%i %s", currentHour, currentMinute, AMPM);
  //  Serial.println(time);

  float subs = (youtube_subscribers.toFloat());
  float subDec;
  char subTrunc[32];
  String subEnd = "Subs";

  if (g_transitionType == E_TRANS_TYPE_SCROLL)
  {
    String decStr = "";
    for (uint8_t idx = 0; idx < youtube_subscribers.length(); idx++)
    {
      if (idx % 3 == 0 && idx != 0) {
        decStr = String(youtube_subscribers[youtube_subscribers.length() - idx - 1]) + "," + decStr;
      } else {
        decStr = String(youtube_subscribers[youtube_subscribers.length() - idx - 1]) + decStr;
      }
    }
    sprintf(subTrunc, "%s Subs", decStr.c_str());
  }
  else
  {
    if (subs >= 1000000.0) {
      subDec = (subs) / 1000000.0;
      subEnd = "M Subs";
      sprintf(subTrunc, "%4.2f%s", subDec, subEnd.c_str());
    }
    else if (subs >= 10000.0 && subs <= 1000000.0) {
      subDec = (subs) / 1000.0;
      subEnd = "K Subs";
      sprintf(subTrunc, "%4.0f%s", subDec, subEnd.c_str());
    }
    else if (subs >= 1.0) {
      subDec = (subs);
      subEnd = " Subs";
      sprintf(subTrunc, "%4.0f%s", subDec, subEnd.c_str());
    }
  //  Serial.println("Subs: ");
  //  Serial.println(subTrunc);
  }

  float views = (youtube_views.toFloat());
  float viewDec;
  char viewTrunc[32];
  String viewEnd = "Views";

  if (g_transitionType == E_TRANS_TYPE_SCROLL)
  {
    String decStr = "";
    for (uint8_t idx = 0; idx < youtube_views.length(); idx++)
    {
      if (idx % 3 == 0 && idx != 0) {
        decStr = String(youtube_views[youtube_views.length() - idx - 1]) + "," + decStr;
      } else {
        decStr = String(youtube_views[youtube_views.length() - idx - 1]) + decStr;
      }
    }
    sprintf(viewTrunc, "%s Views", decStr.c_str());
  }
  else
  {
    if (views >= 10000000.0) {
      viewDec = (views) / 1000000.0;
      viewEnd = "M Views";
      if (viewDec < 1000) {
        sprintf(viewTrunc, "%4.0f%s", viewDec, viewEnd.c_str());
      } else {
        sprintf(viewTrunc, "%d,%d%s", (long)viewDec/1000, long(viewDec)%1000, viewEnd.c_str());
      }
    }
    else if (views >= 1000000.0) {
      viewDec = (views) / 1000000.0;
      viewEnd = "M Views";
      sprintf(viewTrunc, "%4.2f%s", viewDec, viewEnd.c_str());
    }
    else if (views >= 10000.0 && views <= 1000000.0) {
      viewDec = (views) / 1000.0;
      viewEnd = "K Views";
      sprintf(viewTrunc, "%4.2f%s", viewDec, viewEnd.c_str());
    }
    else if (views >= 1000.0) {
      viewDec = (views);
      viewEnd = " Views";
      sprintf(viewTrunc, "%4.0f%s", viewDec, viewEnd.c_str());
    }
    //  Serial.println(viewTrunc);
  }

  char dateStr[32];
  sprintf( dateStr, "%s %d, %d", myMonthStr[month(epochTime) - 1].c_str(), day(epochTime), year(epochTime) );

// 
  myDisplay.setTextAlignment(PA_CENTER);

  feed[(uint8_t)Values::curTime] = time;
  feed[(uint8_t)Values::weekDay] = weekDay;
  //YouTube
  feed[(uint8_t)Values::curDate] = dateStr;
  feed[(uint8_t)Values::yt_views] = viewTrunc;
  feed[(uint8_t)Values::yt_subscribers] = subTrunc;

  if (g_transitionType == E_TRANS_TYPE_SCROLL)
  {
    g_scrollingText = "";

    for (uint8_t i = 0; i < (uint8_t)Values::count; i++)
    {
      if (g_dispState[i] == true)
      {
        g_scrollingText += feed[i];
        g_scrollingText += "   ";
      }
    }
  }
}

static const char* PROGMEM imgTitleSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA5CAMAAAD3LH5PAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDkuMC1jMDAwIDc5LjE3MWMyN2ZhYiwgMjAyMi8wOC8xNi0yMjozNTo0MSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpjYWEzYzhjMy1jZWIwLTRjZGYtODAwMS05MGVmOGY5ODVlNTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDk2MEFGMjE2NEU2MTFFRDhENkQ5NzcyOTVENTAzNkMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDk2MEFGMjA2NEU2MTFFRDhENkQ5NzcyOTVENTAzNkMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjEgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYWEzYzhjMy1jZWIwLTRjZGYtODAwMS05MGVmOGY5ODVlNTYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Y2FhM2M4YzMtY2ViMC00Y2RmLTgwMDEtOTBlZjhmOTg1ZTU2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+OEb8UAAAAAZQTFRFAAAA////pdmf3QAAAgtJREFUeNrMmIlugzAQRGf+/6cbVQbvMesDnKpWJEJw9oH3GgPuD3xGO6Ad2k/97JplLh2DQEH4GgIEw38PaV9PQOg8YGf9D0gZFOuQ66K00iYVKFg/LEIgH8GGyCsIKghcnEwhPrrSLCKvB8I4BoHxBtTYyBM368Z099p/+Zt5GMIOQl960tLsQKoCiR620uQZCOr7ztW6hnADAm87ogcQTpYL+Zl9J+Lj8RvCxnTKA+2WXYhaPISiknxCEaexVVVhoAqMhOAZhBNIdrxM+hHEulaZc5QYgBLCASTn+xrEtcJoCyk72k8ziAnICLH3cIWwzzZIj4t6tga5p/hsQ3yCAqKbY+GHsHze5jIkf68hweYtaB5A4HxyXfIqorOSoIgJMVo6W1bGEFWFkxblMkS5RkM4NJz8w1hwfc+/G8E7iO8XCMoiC00teGcQrzJcBbtu4xQEqTDNtfdy04pdPDb8t813CEllViyXaFzqTEGQ46lWYlDyI5xRKEd/7xhClFVQKekIsZuKu75ptbcPaXloq7/Y9MW17VY9M+W5ybvu//ahUsdBPvnE1hBG2WlDYADBBMJil+AhSiqJHcwyhOW+ihUEbyAYbudFEK1DYmiM3kjIFrwECUHxJQihtkMSEoJ3B7JU1EX6reTJ/lsihMM3Ifq5dO16BGHxYuI0hN+HbDatAxAO2u+PAAMAFaQLyzogP/0AAAAASUVORK5CYII=";

static const char* PROGMEM imgWifi01 = "";
static const char* PROGMEM imgWifi02 = "";
static const char* PROGMEM imgWifi03 = "";
static const char* PROGMEM imgWifi04 = "";
static const char* PROGMEM respTemplate = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n"
                  "<!DOCTYPE html>"
                  "<html>"
                  "<head>"
                  "<meta name='viewport' content='width=device-width, initial-scale=1.0'/>"
                  "<meta charset='utf-8'>"
                  "<style>{{style}}</style>"
                  "<title>DoLibo Matrix Display</title>"
                  "</head>"
                  "<body>{{body}}<script>{{script}}</script></body></html>";
static const char* PROGMEM respStyle = "body { font-size: 110%;font-family: Arial, sans-serif;}#main { display: table; margin: auto; padding: 0 10px 0 10px;}h2 { text-align: center;}.titleimg { width: 100px; height: auto;} .wifi-level {width: 20px; height: auto;} .button { padding: 10px 10px 10px 10px; width: 100%; font-size: 120%; cursor: pointer;}.main-page-url { font-size: 140%; text-decoration: underline;}.large-text { font-size: 120%;}.center { padding-top: 0px; width: 100%; display: flex; flex-direction: column; align-items: center;}.center>div { flex: 1 1 auto; text-align: center; margin: 5px;}.center>input { flex: 1 1 auto; text-align: center;}.center-container { width: 100%; display: flex; flex-direction: row; justify-content: center;}.center-children { width: 90%; display: flex; flex-direction: column;}.center-children > form > input { padding: 10px 10px 10px 10px; width: 100%; display: flex; border-radius: 10px; border-color: gray; border-width: 3px; box-sizing: border-box; border-style: solid;}.center-children > form > .input-label { margin-top: 15px; margin-bottom: 5px; color: gray;}.center-children > form > .btn-submit { width: 100%; display: flex; flex-direction: row; justify-content: center;}.flex-container { display: flex; flex-direction: row; flex-wrap: nowrap; justify-content: center; margin-bottom: 10px;}.flex-container>div { width: 100px; margin: 10px; text-align: center; font-size: 30px;}.flex-container>label { margin: 10px;}.header { margin: 7px 0;}.title { white-space: nowrap; margin: 20px 0;}.yes-btn { width: 150px; padding:10px 15px;margin-bottom: 10px;border-radius: 15px; border-color: transparent; background-color: #24952c; color: white;}.no-btn { width: 150px; padding: 10px 15px; border-radius: 15px; border-color: transparent; background-color: #c72424; color: white;}.continue-btn { width: 200px; margin-top: 20px; padding: 10px 15px; border-radius: 15px; border-color: transparent; background-color: gray; color: white;} .active-btn {width: 200px;margin-top: 20px;padding: 10px 15px;border-radius: 15px;border-color: transparent;background-color: #24952c;color: white;} .table-container { width: 90%}.table-underline { text-decoration: underline; color: gray; cursor: pointer;}";

static const char* PROGMEM webRoot = "<div id='main'> <div class='flex-container'> <a href='home'><img class='titleimg' src='{{titleImg}}' /></a> </div> <h2 class='header'>DoLibo Matrix Display</h2> <div class='center'> <div>Before you do anything...</div> <div>Did you register an account with..</div> <div class='main-page-url'>code.dolibo.com</div> <div class='large-text'>&quest;&quest;&quest;</div> </div> <div class='center'> <a href='select-network'><input class='button yes-btn' type='submit' value='YES'></input></a> </div> <div class='center'> <a href='option-no'><input class='button no-btn' type='submit' value='NO' /></a> </div></div>";

static const char* PROGMEM webOptionNo = "<div id='main'> <div class='flex-container'> <a href='home'><img class='titleimg' src='{{titleImg}}' /></a> </div> <h2 class='header'>DoLibo Matrix Display</h2> <div class='center'> <div>From a computer with an Internet</div> <div>connection go to...</div> <div class='main-page-url'>code.dolibo.com</div> <div>Once you have registered an account</div> <div>remember your username.</div> <div>(Displayed in the upper right corner)</div> </div> <div class='center'> <a href='home'><input class='button active-btn' type='submit' value='CONTINUE' /></a> </div> </div>";

static const char* PROGMEM webSelectNetwork = "<div id='main'><div class='flex-container'><a href='home'><img class='titleimg' src='{{titleImg}}' /></a></div><h2 class='header'>DoLibo Matrix Display</h2>{{networks}}</div>";

static const char* PROGMEM webInputPassword = " <div id='main'> <div class='flex-container'> <a href='home'><img class='titleimg' src='{{titleImg}}' /></a></a> </div> <h2 class='header'>DoLibo Matrix Display</h2> <div class='center-container'> <div class='center-children'> <form action='connect-wifi' method='get'> <div class='input-label'>NETWORK PASSWORD</div> <input type='password' placeholder='Password' id='password' name='password' /> <div class='input-label'>DOLIBO USERNAME</div> <input type='text' placeholder='DoLibo Username' id='username' name='username' /> <div class='btn-submit'> <input disabled class='button continue-btn' type='submit' value='CONNECT' id='btnConnect'/> </div> </form> </div> </div> </div>";

static const char* PROGMEM webWifiConnected = "<div id='main'> <div class='flex-container'> <a href='home'><img class='titleimg' src='{{titleImg}}' /></a>     </div> <h2 class='header'>DoLibo Matrix Display</h2> <div class='center'> <div>After your DOLIBO MATRIX DISPLAY</div> <div>reboots, you can adjust settings</div> <div>and customize your display by</div> <div>logging into...</div> <div class='main-page-url'>code.dolibo.com</div> </div> <script> </script> </div>";

static const char* PROGMEM jsSelectNetwork = "function getId(element) {window.location.href='input-password?id=' + element.closest('tr').rowIndex;};";

static const char* PROGMEM jsInputPassword = "var elUserName = document.getElementById('username');var elPassword = document.getElementById('password');var elBtnConnect = document.getElementById('btnConnect');elUserName.addEventListener('input', handleChangeUserName);elPassword.addEventListener('input', handleChangePassword);function handleChangeUserName(e) {var username = e.target.value;if (elUserName.value.length > 1 && (elPassword.value.length >= 8 || elPassword.value.length == 0)) {elBtnConnect.style.backgroundColor = '#24952c';elBtnConnect.disabled = false;} else {elBtnConnect.style.backgroundColor = 'gray';elBtnConnect.disabled = true;}};function handleChangePassword(e) {var password = e.target.value;if (elUserName.value.length > 1 && (elPassword.value.length >= 8 || elPassword.value.length == 0)) {elBtnConnect.style.backgroundColor = '#24952c';elBtnConnect.disabled = false;} else {elBtnConnect.style.backgroundColor = 'gray';elBtnConnect.disabled = true;}};";

#define GET_WIFI_LEVEL_IMG(lrssi) \
( (-30 <= lrssi && lrssi <= 0)? FPSTR(imgWifi01) : \
(-67 <= lrssi && lrssi <= -30)? FPSTR(imgWifi02) : \
(-70 <= lrssi && lrssi <= -67)? FPSTR(imgWifi03) : FPSTR(imgWifi04) )

void handleNotFound( void )
{
  apserver.send(404, "text/plain", "Page Not found");
}

void handleWebRoot( void )
{
  String response = FPSTR(respTemplate);
  
  response.replace("{{style}}", FPSTR(respStyle));
  response.replace("{{body}}", FPSTR(webRoot));
  response.replace("{{script}}", "");
  response.replace("{{titleImg}}", FPSTR(imgTitleSrc));

  apserver.sendContent( response );
}

void handleOptionNo( void )
{
  String response = FPSTR(respTemplate);
  
  response.replace("{{style}}", FPSTR(respStyle));
  response.replace("{{body}}", FPSTR(webOptionNo));
  response.replace("{{script}}", "");
  response.replace("{{titleImg}}", FPSTR(imgTitleSrc));

  apserver.sendContent( response );
}

void handleInputPassword( void )
{
  String response = FPSTR(respTemplate);

  if (apserver.hasArg("id"))
  {
    g_wifiSsidID = apserver.arg("id").toInt() - 1;
    Serial.print("Selected network index: "); Serial.println(g_wifiSsidID, DEC);
    response.replace("{{style}}", FPSTR(respStyle));
    response.replace("{{body}}", FPSTR(webInputPassword));
    response.replace("{{script}}", FPSTR(jsInputPassword));
    response.replace("{{titleImg}}", FPSTR(imgTitleSrc));
    apserver.sendContent( response );
  }
  else {
    handleNotFound();
  }
}

void handleSelectNetwork( void )
{
  String lssid;
  int32_t rssi;
  uint8_t encryptionType;
  uint8_t* bssid;
  int32_t channel;
  bool hidden;  
  String response = FPSTR(respTemplate);
  String htmlScanResult = "<div class='center'><a href='select-network' ><input class='button active-btn' type='submit' value='REFRESH'/></a><div style='color: gray;'>Select your network...</div><table class='table-container'><tr><th style='width:85%'></th><th></th></tr>";
  
  int scanResult = WiFi.scanNetworks(/*async=*/false, /*hidden=*/true);
  g_networkNum = scanResult;

  if (scanResult == 0)
  {
    Serial.println(F("No networks found"));
  } 
  else if (scanResult > 0)
  {
    Serial.printf(PSTR("%d networks found:\r\n"), scanResult);

    // Print unsorted scan results
    for (int8_t i = 0; i < scanResult; i++)
    {
      WiFi.getNetworkInfo(i, lssid, encryptionType, rssi, bssid, channel, hidden);

      htmlScanResult += "<tr onclick='getId(this)'>";
      htmlScanResult += "<td class='table-underline'>" + lssid + "</td>";
      htmlScanResult += "<td><img class='wifi-level' src='" + String(GET_WIFI_LEVEL_IMG(rssi)) + "'/></td></tr>";

      Serial.printf(PSTR("  %02d: [CH %02d] [%02X:%02X:%02X:%02X:%02X:%02X] %ddBm %c %c %s\r\n"),
                    i,
                    channel,
                    bssid[0], bssid[1], bssid[2],
                    bssid[3], bssid[4], bssid[5],
                    rssi,
                    (encryptionType == ENC_TYPE_NONE) ? ' ' : '*',
                    hidden ? 'H' : 'V',
                    lssid.c_str());
    }
  } else {
    Serial.printf(PSTR("WiFi scan error %d"), scanResult);
  }

  htmlScanResult += "</table></div>";

  response.replace("{{style}}", FPSTR(respStyle));
  response.replace("{{script}}", FPSTR(jsSelectNetwork));
  response.replace("{{body}}", FPSTR(webSelectNetwork));
  response.replace("{{networks}}", htmlScanResult);
  response.replace("{{titleImg}}", FPSTR(imgTitleSrc));

  apserver.sendContent( response );
}

void handleWifiConnected( void )
{
  String response = FPSTR(respTemplate);
  
  response.replace("{{style}}", FPSTR(respStyle));
  response.replace("{{body}}", "");
  response.replace("{{script}}", "");
  response.replace("{{titleImg}}", FPSTR(imgTitleSrc));

  apserver.sendContent( response );
}

void handleConnectWifi( void )
{
  String lusername, lwifipass, errmsg, response = FPSTR(respTemplate);
  uint8_t i = 0;

  if (apserver.hasArg("username") && apserver.hasArg("password"))
  {
    lusername = apserver.arg("username");
    lwifipass = apserver.arg("password");
    
    if (lusername.length() > 1 && (lwifipass.length() >= 8 || lwifipass.length() == 0))
    {
      String lssid;
      int32_t rssi;
      uint8_t encryptionType;
      uint8_t* bssid;
      int32_t channel;
      bool hidden;

      WiFi.getNetworkInfo(g_wifiSsidID, lssid, encryptionType, rssi, bssid, channel, hidden);
      Serial.print("Wifi index: "); Serial.println(g_wifiSsidID, DEC);
      Serial.print("Wifi SSID:  "); Serial.println(lssid);

      for (i = 0; i < lssid.length(); i++)
      {
        EEPROM.write(EP_WIFI_SSID_ADDR + i, lssid[i]);
      }
      EEPROM.write(EP_WIFI_SSID_ADDR + i, 0);
      
      for (i = 0; i < lwifipass.length(); i++)
      {
        EEPROM.write(EP_WIFI_PASSWORD_ADDR + i, lwifipass[i]);
      }
      EEPROM.write(EP_WIFI_PASSWORD_ADDR + i, 0);

      for (i = 0; i < lusername.length(); i++)
      {
        EEPROM.write(EP_DOLIBO_USERNAME_ADDR + i, lusername[i]);
      }
      EEPROM.write(EP_DOLIBO_USERNAME_ADDR + i, 0);

      EEPROM.write(EP_START_MODE_ADDR, START_MODE_COUNTER_MAX);
      EEPROM.commit();

      response.replace("{{style}}", FPSTR(respStyle));
      response.replace("{{body}}", FPSTR(webWifiConnected));
      response.replace("{{script}}", "");
      response.replace("{{titleImg}}", FPSTR(imgTitleSrc));
      apserver.sendContent( response );

#if 1
      unsigned long lreset_time = millis();
      while (millis() - lreset_time < 3000) {
        yield();
      }
      ESP.restart();
#endif
    } else {
      Serial.print("Invalid Wifi information: ");
      Serial.print(ssid); Serial.print(" - ");
      Serial.print(password); Serial.println(".");
      apserver.send(404, "text/plain", "Invalid SSID or password");
    }
  }
  else {
    handleNotFound();
  }
}
